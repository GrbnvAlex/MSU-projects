## Задание 2 - Абстрактный тип данных

Необходимо на Си++ реализовать и протестировать новый класс, представляющий 
абстрактный тип данных, т.е. такой, пользователи которого могут обращаться
только к публичными операциями, предусмотренными создателем класса, и не имеют
информации о внутреннем его устройстве.

Здесь и далее пользователем (клиентом) класса считается не "пользователь программы" или
"компьютерный пользователь" вообще, а программист, использующий Ваш класс
для решения своих задач, пишущий свою программу на его основе. 
Иногда также под пользователями класса понимаются другие классы,
фрагменты программ, которые пользуются его услугами.

Ниже перечислены варианты понятий, которые нужно представить новым классом.
Можно определить несколько дополнительных классов, на том же уровне или вложенных, 
однако основной проверке подвергается главный класс. В некоторых вариантах
есть подварианты -- одно- или двунаправленный список, чем ограничена длина строки и т.п.,
влияющие на сложность задания. Среди подвариантов нужно сделать свой выбор и отразить его в README. 
Чем сложнее вариант/подварианты, тем больше баллов можно получить за выполненное задание. 

Расширение предложенного набора операций, и прочее превышение задания 
(при сохранении правильности базовой части) приветствуется и награждается :)

## Требования

Программа формируется в виде следующего набора файлов (например, для стека строк): 
```c
  README
  Makefile
  string_stack.h
  string_stack.cpp
  main.cpp
```

В файле **string_stack.h** должно быть объявлено все, что необходимо включить в программу,
использующую класс `string_stack`, в **string_stack.cpp** -- описаны реализации нетривиальных методов класса 
(если содержат более одного-двух операторов), краткие методы можно оставить в заголовке.

В **main.cpp** должна быть реализована программа, тестирующая указанный класс в подробном режиме,
выводя в `stderr` номера или названия испытаний и их результаты или ошибки. В ходе проверки
задания в первые два файла будут вносится незапланированные изменения, нарушающие работу
класса, и тестирующая программа должна их отлавливать (в том числе и на стадии компиляции,
т.е., она должна содержать явные или неявные обращения ко всем реализованным методам)
 и грамотно диагностировать ошибки (в том числе и на стадии выполнения, например, если метод вернул
не то, что должен), и ни в коем случае не "падать" сама, скажем, по защите памяти (`segmentation fault`). 

**Makefile** должен содержать цели `clean` для уборки за собой, а также `test`,
которая компилирует ****main.cpp** и прогоняет все тесты (по умолчанию подразумевается цель `test`).

Для класса, реализующего АТД, необходимо определить: 

 * конструктор по умолчанию
 * конструктор копирования (глубокое копирование, никаких общих ресурсов!)
 * операцию присваивания (все своё предварительно освободить + см. строку выше относительно копирования)
 * деструктор (соответственно, никаких повторных освобождений!)
 * базовый класс исключения, выбрасываемого всеми операциями класса, возможно
   с потомками -- для более детальной классификации ошибок. Вложен в основной класс,
   например `string_list::error`.

## Список строк (`string list`)

  Строка понимается в стиле Си: `char *`, на конце `\0`. 

  Выбрать: 
  1) Длина строки ограничена константой или объемом оперативной памяти
  2) Однонаправленный или двунаправленный

### Обязательные возможности:
  ```cpp
    list( char* )          // конструктор списка из одного элемента

    list + list            // вернуть конкатенацию списков, операнды неизменны
    list += list           // присоединить к первому списку, второй неизменен
    char* + list           // добавить элемент в начало списка
    list + char*           // добавить элемент в конец списка
    list - char*           // удалить элемент, если есть
    list[i]                // получить копию i-го элемента
   
    приведение к char* ()  // выписать все элементы через \n
  ```

### Дополнительные возможности:
  ```cpp
    // реализовать независимость всех операций от пробелов в начале или в конце строк, т.е. 
    //   можно добавить "abc ", затем успешно удалить " abc  ".
    list * list     // для списков одной длины, построить список пар через \n, по одной строке из каждого списка
    list[i] = char* // вставить элемент на i-е место, со сдвигом остальных вперед
  ```
