## Задание 3 (Часть 2)

## Как тестировать шелл

Основная идея в том, чтобы из **test.c** вызвать **shell_andor** с такими аргументами, чтобы они 
позволяли отличить правильно работающий шелл от неправильно работающего. Для test.c утилита 
shell_andor - черный ящик, о правильности ее работы можно судить только по тому, что она выдает
на стандартные потоки ввода-вывода (для этого нужно перенаправить стандартный вывод `shell_andor`
в канал, тогда в **test.c** можно будет считать данные из этого канала и проверить, что вывела `shell_andor`),
по времени с момента ее запуска до момента завершения (здесь может помочь функция `wait4`, 
которая позволяет узнать длительность работы завершившегося процесса - 
см. https://ejudge.ru/study/3sem/unix.shtml) и по тем процессам, которые она порождает 
(тут может помочь утилита `ps`, которая выводит запущенные в текущий момент процессы с 
информацией об их родителях, статусе - в т.ч. процессы зомби, и др.).

Например,
1)  Чтобы проверить, что в конструкции `pr1 && pr2` вторая часть запускается тогда и только тогда, 
когда первая успешно завершается, можно
    * запустить `shell_andor`, задав в качестве `pr1` команду, которая завершается успешно, а в 
    качестве `pr2` команду, которая выводит заранее известную строку, и проверить, что на 
    стандартном выводе `shell_andor` появилась эта строка
    * запустить `shell_andor`, задав в качестве `pr1` команду, которая завершается неуспешно, а в 
    качестве `pr2` команду, которая выводит заранее известную строку, и проверить, что на стандартном 
    выводе `shell_andor` НЕ появилась эта строка
    
    Например, команда `true && echo abc` должна выдать на стандартный вывод строку `abc`, 
    а `false && echo abc` - ничего не выдать на стандартный вывод (отмечу, что `true` и `false` -
     не константы, а такие же стандартные утилиты, как `ls`, `cat`, `pwd` - см. `man false`, `man true`).
2) Чтобы проверить, что конструкция `pr1 && pr2` завершается только когда завершается последняя 
из запущенных утилит, можно в качестве `pr1` и `pr2` взять программы, которые работают заведомо 
известное время и замерить время работы `shell_andor` - оно должно быть примерно равно сумме 
времен работы `pr1` и `pr2` (если `pr1` завершается успешно). 
Например, команда `sleep 3 && sleep ` должна завершиться через 8 секунд 

## Как протестировать, что шелл собирает зомби

Утилита `ps` позволяет выводить список процессов в системе, включая информацию об их состоянии 
(выполняются, остановлены, зомби и пр.) и `pid` родительского процесса (нужные флаги - см. `man ps`). 
Для начала напишите функцию, которая запускает `ps` с нужными аргументами и возвращает список `pid`-ов 
процессов-зомби, у которых шелл является либо непосредственным, либо опосредованным родителем.

Чтобы проверить, что шелл собирает зомби, можно дать задание вашему шеллу запустить какой-нибудь 
конвейер в фоновом режиме (т.е. передать на его `stdin` соотв. строку, для чего можно связать вашу 
тестирующую программу с шеллом каналом и записать эту строку в канал - шелл ее прочитает и выполнит).

После этого могут появиться зомби (если шелл собирает зомби, например, после выполнения очередной 
команды, то они будут висеть до того момента, как шелл получит следующую команду и выполнит ее) - 
список зомби нужно запомнить. После этого можно дать задание шеллу на выполнение еще одной команды - 
после нее могут появиться новые зомби, но зомби из запомненного списка должны исчезнуть.

## `shell_pipe` - структуры данных

По окончании всех процессов в конвейере вывести сообщение об этом с указанием исходной команды-конвейера 
и статусом ее завершения (статусом завершения конвейера считается статус завершения последнего его элемента)

**Как это реализовать?** 

Нужно запоминать каждую команду, запущенную  в фоновом режиме, в специальном списке и удалять ее оттуда 
только тогда, когда завершаться все процессы, с ней связанные (после печати информации о ее завершении). 

Каждая команда может быть представлена списком, звено которого содержит: имя программы, ее аргументы, 
pid процесса в котором ее запустили, статус его завершения - тогда при завершении очередного дочернего 
процесса можно зная его `pid` легко найти и вывести имя соотв. программы, а также присвоить полю `pid`, 
например, `-1`. 

Если поля `pid` в текущем списке все равны `-1`, значит команда завершилась - распечатать 
исходную команду можно, пройдя по списку и распечатав имена и аргументы из каждого звена. Статус 
завершения взять из последнего звена списка.
