# Задание 2 - Построение частотного словаря

___

## На оценку 3

* Выделить функцию `getline_unlim` из задания 1 в отдельный модуль `util` (если задание 1 не
выполнялось, необходимо описать такую функцию); для этого создать заголовочный файл **util.h** с
прототипом функции и **util.c** с ее описанием. Утилиты `wordsplit` и `countd` необходимо оформить как
многомодульные программы; файлы **wordsplit.c** и **countd.c** должны подключать заголовочный файл 
**util.h**
с помощью директивы `#include` и использовать функцию `getline_unlim`. В модуль `util` можно добавить
другие полезные функции (по вкусу).

* Реализовать утилиту `wordsplit`, которая разбивает текст на стандартном вводе на слова, при наличии флага `-l` конвертирует
слова в нижний регистр (`VaSYa -> vasya`), выводит на стандартный вывод по одному слову в строке.

* Реализовать утилиту `countd`, которая считывает строки со стандартного ввода и выводит их на стандартный вывод;
повторяющиеся подряд идущие строки выдаёт 1 раз; слева от каждой строки выводит количество повторов.  
Формат вывода:

    `<Количество повторов, выровненное по правому краю поля шириной 4 символа><Пробел><Исходная строка>`

* С помощью написанных утилит и операторов шелла `|`, `<`, `>` сформировать частотный
словарь — файл **dict.txt**, в котором для любого слова указано число его вхождений в
исходный текст (пример — ниже). Исходный текст сформировать, скачав с помощью
утилиты `wget` как минимум 10 англоязычных текстов и объединив их с помощью
утилиты `cat`.
  * Для разбиения на слова достаточно заменить все пробельные символы и знаки препинания на символ
  перевода строки.
  * Сборку реализовать с помощью утилиты `make`: создать файл **Makefile** с целями `all` 
  (сборка обеих утилит),
  `wordsplit` (сборка утилиты `wordsplit`, `countd` (сборка утилиты `countd`), `util.o` 
  (сборка объектного файла `util.o`); прописать зависимости между целями, зависимости целей 
  от файлов, команды сборки целей.
  * Утилита таке описана в http://www.stolyarov.info/books/pdf/unixref.pdf (параграф 4.3) и
  https://ejudge.ru/study/3sem/makefile.pdf (читать оба файла!).  
  
  
  ```c
     4 wisdom
     1 wise
     3 wish
     2 wished
     1 wishes
     1 wit
   138 with
     9 within
    21 without
     1 withnesses
     1 wonderful
  ```

___

## На оценку 4 

*То же, что на 3 плюс* 

* Изучить стандартные утилиты (`tr`, `uniq` и поддерживаемые ими флаги (`man tr`, `man uniq`); 
предложить решение задачи формирования частотного словаря, использующее только
стандартные утилиты `sort`, `tr`, `uniq`. Сравнить производительность двух полученных решений на исходных
текстах различного размера.

* Изучить флаги `-r`, `-k`, `-n` утилиты `sort`. Каким образом можно упорядочить словарь по числу вхождений
‘слова в текст (начиная с наиболее частотных)?

* Добавить в **Makefile** цели `data` (скачивает указанные в `books` файлы и объединяет их содержимое в один
файл `data`), `dict_std.txt` (строит частотный словарь с помощью стандартных утилит, выводит затраченное
время), `dict.txt` (строит частотный словарь с помощью созданных утилит, выводит затраченное время).
Добавить необходимые зависимости, чтобы при изменении файла `books` (например, добавлении новой
ссылки) цели `dict_std.txt` и `dict.txt` становились устаревшими и словари перестраивались.

* Добавить цель `test`, которая запускает оба способа построения частотного словаря и выводит затраченное
время, чтобы можно было сравнить производительность.

* Добавить цель `sorted_dict.txt`, которая строит словарь, слова в котором упорядочены по частоте (начиная
с наиболее частотных).

___

## На оценку 5

*То же, что на 4 плюс* 

* Реализовать утилиту `freqdict`, строящую частотный словарь более эффективным способом —
без сортировки. Утилита считывает строки со стандартного ввода, разбивает их на слова и заносит слова в
‘ассоциативный массив (ключ — слово, значение — число вхождений). Ассоциативный массив реализовать с
помощью хэш-таблицы в отдельном модуле `hashtable`.

* Сравнить производительность утилиты `freqdict` и двух предложенных ранее решений (добавить и
модифицировать соответствующие цели).

___

## Замечания

Для выполнения задания понадобится утилита сортировки строк со стандартного ввода. Если есть свои
утилиты `linesort`/`linesort_tree`, необходимо использовать их; если нет — воспользоваться стандартной
утилитой `sort`.

Необходимо загрузить следующие файлы:
* на 3: **util.h**, **util.c**, **wordsplit.c**, **countd.c**, **dict.txt**, **Makefile**;
* на 4: **util.h**, **util.c**, **wordsplit.c**, **countd.c**, **Makefile**, **report.txt** или **report.pdf**;
* на 5: **util.h**, **util.c**, **wordsplit.c**, **countd.c**, **hashtable.h**, **hashtable.c**, **freqdict.c**, 
**Makefile**, **report.txt** или **report.pdf**.

В отчете (**report.txt** или **report.pdf**) необходимо отразить результаты замера производительности предложенных решений.

**Обратите внимание!**
Ни в `wordsplit`, ни в `countd` не нужно ни в коем случае создавать список! В отличие от сортировки 
(где для того чтобы отсортировать, нужно сначала все считать), эти утилиты можно и нужно реализовать 
в потоковом режиме - т.е. считали порцию данных со стандартного ввода - обработали ее - вывели на 
станадртный вывод. При таком подходе вы сможете обрабатывать входные файлы любого размера, тогда 
как при считывании всего в список вы будете ограничены размером доступной программе памяти.

___
